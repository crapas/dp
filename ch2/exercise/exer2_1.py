def ways_to_go(N, M = -1):
    # 초기 호출
    if M == -1:
        M = N
    
    # 오른쪽, 아래쪽으로만 이동 가능하므로 어떤 셀 arr[i][j]로 이동하는 방법은
    # arr[i - 1][j]에서 아래쪽으로 이동하거나 arr[i][j - 1]에서 오른쪽으로
    # 이동하는 두 가지 방법 뿐 입니다.
    # 그리고, arr[i - 1][j]에서 arr[i][j - 1]로 이동하거나, 그 반대의 이동은
    # 불가능하므로 두 가지 경우는 겹치지 않습니다.
    # 그러므로 ways_to_go(i, j) = ways_to_go(i - 1, j) + ways_to_go(i, j - 1)이
    # 성립합니다.
    # 단, 배열이므로 가장자리 조건은 확인해야 합니다. 그리고 가장 위 줄과 가장 왼쪽 줄의
    # 위치는, (1, 1)에서 오른쪽 또는 아래쪽으로 이동하는 단 한가지 경우만 가능합니다.
        
    # 종료 조건. N이 0 이하이거나 이상한 값인 경우는 없다고 가정하겠습니다.
    # 가장 왼쪽 또는 가장 윗 줄의 경우
    if N == 1 or M == 1:
        return 1
    return ways_to_go(N - 1, M) + ways_to_go(N, M - 1)

print("N = 4일 때 모든 경우의 수 :", ways_to_go(4))
