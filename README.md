# 다이내믹 프로그래밍 완전 정복
한빛미디어의 '다이내믹 프로그래밍 완전 정복'의 예제 코드를 제공합니다.
http://www.yes24.com/Product/Goods/79257722?scode=032&OzSrank=2 (YES24)
https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=209342722 (알라딘)


디렉토리의 구조는 다음과 같습니다.

- Appendix : 부록 A, B의 소스 코드
- ch1 : 1장의 소스 코드, 연습문제 솔루션
- ch2 : 2장의 소스 코드, 연습문제 솔루션
- ch3 : 3장의 소스 코드, 연습문제 솔루션
- ch4 : 4장의 소스 코드, 연습문제 솔루션
- ch5 : 5장의 소스 코드, 연습문제 솔루션

**NOTE** 각 장의 디렉터리 안에 다시 c와 python 디렉터리가 들어 있으며 각각 c 버전의 예제와 파이썬 버전의 예제가 수록되어 있습니다. 단 원저자는 예제 코드를 제공하지 않고 있습니다.

**NOTE** 안 바쁜 사람이 어디 있겠습니까? 바쁘다는 것은 다 변명이지요. 다 제가 게으른 탓에, 그리고 기억력도 나빠서 깜빡하고 있다가 이제서야 생각이 났습니다. 연습문제 코드 모두 작성해서 올렸습니다. 그리고 역시 변명인데, 당시 원서가 C로 만들어진 코드이다보니 책 내용이 전달이 잘 될 것 같지 않아서 급하게 파이썬을 공부하면서 파이썬 코드로 만들어 추가 제공했습니다만, 당시 코딩 스타일이나 일부 코드 작성법이 문제가 있었습니다. 파이썬 코드를 리팩토링하면서 특히 메모이제이션을 파이썬에 적용하는 좋은 방법을 정리해 두었으니 반드시 코드 2-4와 코드 2-5의 예제 파이썬 코드를 확인하시기 바랍니다.

반성의 취지...라고 하기는 좀 그렇지만, 여하튼 조만간 유튜브에 알고리즘 관련 몇 개의 동영상을 만들어 게시할 예정입니다. 게시하게 되면 리파지토리에도 공지하겠습니다.

# 책의 오류나 참고 사항입니다.
## 2장
- 각주 8에 대하여. 각주 8은 메모를 저장할 크기를 확정할 수 없을 때 메모이제이션이 도움이 되지 않을 수도 있다는 원론적인 이야기입니다. 당연히 컴퓨터 메모리를 다 잡아먹을 만한 메모이제이션을 하고자 한다면, 그 전에 프로그램이 종료가 될 것이며, 현실적으로 그런 문제가 많지도 않습니다. 성능을 생각하면 당연히 메모이제이션이 크게 도움이 됩니다. 많은 문제에서는... 오히려 메모이제이션이 도움이 되지 않는 문제는 문제의 성격을 기준으로 확인해야 하는 경우가 일반적입니다.

## 5장
- 그림 5-29에서 물건과 배낭 용량이 바뀌었습니다. 가로가 배낭 용량이며, 세로가 물건입니다.

# 예시 코드 및 연습 문제와 관련된 오류 또는 기타 수정 사항
## 1장
- 연습문제 1-1의 문제의 설명처럼 계승은 음이 아닌 정수에 대해서 계산할 수 있습니다. 그런데 아래 점화식에서는 n = 0일 때의 경우를 제시하지 않은 오류가 있습니다. 0의 계승값은 1로 정의됩니다.
- 코드 1-12에서, n = 1일 경우를 종료 조건으로 제시하였습니다. 그런데 놀랍게도 C에서 길이가 0인 배열을 선언할 수 있고 (아, 이 사실을 이제서야 알았습니다.), 파이썬에서 빈 리스트는 매일 만드는 무엇인가입니다. 코드를 수정해 두었습니다.

## 2장
- 코드 2-4와 코드 2-5의 파이썬 버전 코드에서 메모이제이션 변수를 사용하는 가장 깔끔한 방법을 확인할 수 있도록 수정하였습니다. 해당 코드를 참고하세요.
## 5장
- 코드 5-3, 코드 5-4에서 시작 지점과 도착 지점이 동일한 경우는 0을 반환합니다. 만약 문제에서 이러한 경우는 이동이 아니니까 경우의 수를 0으로 한다고 하면 맞는 답입니다만, 가만히 있으면 되는 경우도 하나의 방법이라고 한다면 1을 반환해야 합니다. 원서가 0을 기준으로 예제를 제시하고 있습니다만, 대부분의 경우 이 때 1을 답으로 하고 있습니다. 예제 코드를 수정하였습니다.
- 연습문제 5-7의 경우는 문제가 다소 모호합니다. 우선 배열에 중복된 값이 없으면 모호하지 않지만, 중복된 값이 있는 경우가 그러합니다. [1, 2, 2, 3]에서 합이 5가 되는 쌍을 찾아야 할 때 답이 `[(2, 3)]`일 수도 있고 `[(2, 3), (2, 3)]`일 수도 있으니까요. 어느쪽이라도 좋습니다. 시간 복잡도와 공간 복잡도만 신경쓰고 구현하시기 바랍니다. 그리고 반환하기 위한 결과를 저장하는 변수의 공간 복잡도도 고려하지 않도록 합시다.
